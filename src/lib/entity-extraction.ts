import nlp from 'compromise'

/**
 * Entity types supported by the application
 */
export type EntityType = 'person' | 'organization' | 'location' | 'date' | 'other'

/**
 * Structure representing an extracted entity
 */
export interface Entity {
  id: string
  name: string
  type: EntityType
  mentions: number
  aliases: string[]
  summary?: string  // Summary of the entity generated by DeepSeek (optional)
}

/**
 * Structure representing a relationship between entities
 */
export interface Relationship {
  id: string
  source: string
  target: string
  strength: number
}

/**
 * Result of entity extraction process containing entities and their relationships
 */
export interface ExtractionResult {
  entities: Entity[]
  relationships: Relationship[]
}

/**
 * Extracts named entities from provided text using NLP processing
 */
export function extractEntities(text: string): Entity[] {
  // Use compromise for initial entity extraction
  const doc = nlp(text)
  
  // Extract people
  const people = doc.people().out('array').map((name: string) => ({
    id: `person-${name.toLowerCase().replace(/\s+/g, '-')}`,
    name,
    type: 'person' as EntityType,
    mentions: countOccurrences(text, name),
    aliases: []
  }))
  
  // Extract organizations
  const organizations = doc.organizations().out('array').map((name: string) => ({
    id: `org-${name.toLowerCase().replace(/\s+/g, '-')}`,
    name,
    type: 'organization' as EntityType,
    mentions: countOccurrences(text, name),
    aliases: []
  }))
  
  // Extract places
  const places = doc.places().out('array').map((name: string) => ({
    id: `loc-${name.toLowerCase().replace(/\s+/g, '-')}`,
    name,
    type: 'location' as EntityType, 
    mentions: countOccurrences(text, name),
    aliases: []
  }))
  
  // Extract dates - compromise might not have dates() method in all versions,
  // so we'll use a more generic approach
  const dateTerms = doc.match('#Date').out('array')
  const dates = dateTerms.map((name: string) => ({
    id: `date-${name.toLowerCase().replace(/\s+/g, '-')}`,
    name,
    type: 'date' as EntityType,
    mentions: countOccurrences(text, name),
    aliases: []
  }))
  
  // Combine all entities and remove duplicates
  return deduplicateEntities([...people, ...organizations, ...places, ...dates])
}

/**
 * Identifies relationships between entities based on co-occurrence in text
 */
export function identifyRelationships(text: string, entities: Entity[]): Relationship[] {
  const relationships: Relationship[] = []
  const sentences = nlp(text).sentences().out('array')
  
  // Process each sentence to find co-occurring entities
  sentences.forEach((sentence: string) => {
    const entitiesInSentence = entities.filter(entity => 
      sentence.includes(entity.name) || 
      entity.aliases.some(alias => sentence.includes(alias))
    )
    
    // Create relationships for co-occurring entities
    for (let i = 0; i < entitiesInSentence.length; i++) {
      for (let j = i + 1; j < entitiesInSentence.length; j++) {
        const source = entitiesInSentence[i].id
        const target = entitiesInSentence[j].id
        
        // Check if relationship already exists
        const existingRelIndex = relationships.findIndex(
          r => (r.source === source && r.target === target) || 
               (r.source === target && r.target === source)
        )
        
        if (existingRelIndex >= 0) {
          // Increment strength of existing relationship
          relationships[existingRelIndex].strength += 1
        } else {
          // Create new relationship
          relationships.push({
            id: `rel-${source}-${target}`,
            source,
            target,
            strength: 1
          })
        }
      }
    }
  })
  
  return relationships
}

/**
 * Process text and extract both entities and their relationships
 */
export function processText(text: string): ExtractionResult {
  const entities = extractEntities(text)
  const relationships = identifyRelationships(text, entities)
  
  return {
    entities,
    relationships
  }
}

/**
 * Helper function to count occurrences of a term in text
 */
function countOccurrences(text: string, term: string): number {
  const regex = new RegExp(`\\b${term}\\b`, 'gi')
  const matches = text.match(regex)
  return matches ? matches.length : 0
}

/**
 * Helper function to deduplicate entities and merge their mentions
 */
function deduplicateEntities(entities: Entity[]): Entity[] {
  const entitiesMap = new Map<string, Entity>()
  
  entities.forEach(entity => {
    const key = entity.name.toLowerCase()
    
    if (entitiesMap.has(key)) {
      const existing = entitiesMap.get(key)!
      existing.mentions += entity.mentions
      
      // Keep the more specific entity type if possible
      if (existing.type === 'other' && entity.type !== 'other') {
        existing.type = entity.type
      }
    } else {
      entitiesMap.set(key, { ...entity })
    }
  })
  
  return Array.from(entitiesMap.values())
} 